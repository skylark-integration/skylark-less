{"version":3,"sources":["engine/functions/number.js"],"names":["Dimension","require","Anonymous","functionRegistry","mathHelper","minMax","isMin","args","Array","prototype","slice","call","length","type","message","i","j","current","currentUnified","referenceUnified","unit","unitStatic","unitClone","order","values","toString","undefined","value","unify","push","isArray","apply","map","a","toCSS","this","context","join","compress","addMultiple","min","arguments","max","convert","val","convertTo","pi","Math","PI","mod","b","pow","x","y","percentage","n","_math","num"],"mappings":";;;;;;;AAAA,IAAIA,UAAYC,QAAQ,qBACpBC,UAAYD,QAAQ,qBACpBE,iBAAmBF,QAAQ,uBAC3BG,WAAaH,QAAQ,oBAErBI,OAAS,SAAUC,EAAOC,GAE1B,QADAA,EAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,IACrBK,QACT,KAAK,EAAG,MAAQC,KAAM,WAAYC,QAAS,kCAE/C,IAAIC,EAAGC,EAAGC,EAASC,EAAgBC,EAAkBC,EAAMC,EAAYC,EACnEC,KACAC,KAEJ,IAAKT,EAAI,EAAGA,EAAIR,EAAKK,OAAQG,IAEzB,IADAE,EAAUV,EAAKQ,cACUf,UAWzB,GAHAqB,EAAsB,MADtBD,EAA0C,MAD1CF,EAA6C,KAA5BD,EAAQG,KAAKK,iBAAmCC,IAAdJ,EAA0B,IAAItB,UAAUiB,EAAQU,MAAOL,GAAWM,QAAUX,EAAQW,SACjHR,KAAKK,iBAAoCC,IAAfL,EAA2BA,EAAaH,EAAeE,KAAKK,kBACjEC,IAAfL,GAAqC,KAATD,GAAoD,KAArCG,EAAM,GAAGK,QAAQR,KAAKK,WAAoBL,EAAOC,EACxHC,EAAqB,KAATF,QAA6BM,IAAdJ,EAA0BL,EAAQG,KAAKK,WAAaH,OAErEI,KADVV,OAAmBU,IAAfF,EAAO,KAA8B,KAATJ,GAAeA,IAASC,EAAaG,EAAO,IAAMA,EAAOJ,IASzFD,EAAgD,KAA7BI,EAAMP,GAAGI,KAAKK,iBAAmCC,IAAdJ,EAA0B,IAAItB,UAAUuB,EAAMP,GAAGW,MAAOL,GAAWM,QAAUL,EAAMP,GAAGY,SACvItB,GAASY,EAAeS,MAAQR,EAAiBQ,QACjDrB,GAASY,EAAeS,MAAQR,EAAiBQ,SAClDJ,EAAMP,GAAKC,OAXf,CACI,QAAmBS,IAAfL,GAA4BD,IAASC,EACrC,MAAQR,KAAM,WAAYC,QAAS,sBAEvCU,EAAOJ,GAAQG,EAAMX,OACrBW,EAAMM,KAAKZ,QAfPT,MAAMsB,QAAQvB,EAAKQ,GAAGY,QACtBnB,MAAMC,UAAUoB,KAAKE,MAAMxB,EAAMC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAKQ,GAAGY,QAuBhF,OAAoB,GAAhBJ,EAAMX,OACCW,EAAM,IAEjBhB,EAAOgB,EAAMS,IAAI,SAAUC,GAAK,OAAOA,EAAEC,MAAMC,KAAKC,WAAaC,KAAKF,KAAKC,QAAQE,SAAW,IAAM,MAC7F,IAAIpC,WAAWI,EAAQ,MAAQ,OAAS,IAAMC,EAAO,OAEhEJ,iBAAiBoC,aACbC,IAAK,WACD,OAAOnC,QAAO,EAAMoC,YAExBC,IAAK,WACD,OAAOrC,QAAO,EAAOoC,YAEzBE,QAAS,SAAUC,EAAKxB,GACpB,OAAOwB,EAAIC,UAAUzB,EAAKO,QAE9BmB,GAAI,WACA,OAAO,IAAI9C,UAAU+C,KAAKC,KAE9BC,IAAK,SAAShB,EAAGiB,GACb,OAAO,IAAIlD,UAAUiC,EAAEN,MAAQuB,EAAEvB,MAAOM,EAAEb,OAE9C+B,IAAK,SAASC,EAAGC,GACb,GAAiB,iBAAND,GAA+B,iBAANC,EAChCD,EAAI,IAAIpD,UAAUoD,GAClBC,EAAI,IAAIrD,UAAUqD,QACf,KAAMD,aAAapD,WAAgBqD,aAAarD,WACnD,MAAQa,KAAM,WAAYC,QAAS,6BAGvC,OAAO,IAAId,UAAU+C,KAAKI,IAAIC,EAAEzB,MAAO0B,EAAE1B,OAAQyB,EAAEhC,OAEvDkC,WAAY,SAAUC,GAKlB,OAJanD,WAAWoD,MAAM,SAASC,GACnC,OAAa,IAANA,GACR,IAAKF","file":"../../../engine/functions/number.js","sourcesContent":["var Dimension = require('../tree/dimension'),\n    Anonymous = require('../tree/anonymous'),\n    functionRegistry = require('./function-registry'),\n    mathHelper = require('./math-helper.js');\n\nvar minMax = function (isMin, args) {\n    args = Array.prototype.slice.call(args);\n    switch (args.length) {\n        case 0: throw { type: 'Argument', message: 'one or more arguments required' };\n    }\n    var i, j, current, currentUnified, referenceUnified, unit, unitStatic, unitClone,\n        order  = [], // elems only contains original argument values.\n        values = {}; // key is the unit.toString() for unified Dimension values,\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof Dimension)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;\n        unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw { type: 'Argument', message: 'incompatible types' };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();\n        if ( isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');\n    return new Anonymous((isMin ? 'min' : 'max') + '(' + args + ')');\n};\nfunctionRegistry.addMultiple({\n    min: function () {\n        return minMax(true, arguments);\n    },\n    max: function () {\n        return minMax(false, arguments);\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new Dimension(Math.PI);\n    },\n    mod: function(a, b) {\n        return new Dimension(a.value % b.value, a.unit);\n    },\n    pow: function(x, y) {\n        if (typeof x === 'number' && typeof y === 'number') {\n            x = new Dimension(x);\n            y = new Dimension(y);\n        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n            throw { type: 'Argument', message: 'arguments must be numbers' };\n        }\n\n        return new Dimension(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        var result = mathHelper._math(function(num) {\n            return num * 100;\n        }, '%', n);\n\n        return result;\n    }\n});\n"]}