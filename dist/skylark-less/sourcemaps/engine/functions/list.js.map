{"version":3,"sources":["engine/functions/list.js"],"names":["Comment","require","Dimension","Declaration","Expression","Ruleset","Selector","Element","functionRegistry","getItemsFromNode","node","Array","isArray","value","addMultiple","_SELF","n","extract","values","index","length","range","start","end","step","from","to","stepValue","list","i","push","unit","each","rs","newRules","iterator","rules","ruleset","valueName","keyName","indexName","params","name","key","item","slice","this","currentFileInfo","strictImports","visibilityInfo","eval","context"],"mappings":";;;;;;;AAAA,IAAIA,QAAUC,QAAQ,mBAClBC,UAAYD,QAAQ,qBACpBE,YAAcF,QAAQ,uBACtBG,WAAaH,QAAQ,sBACrBI,QAAUJ,QAAQ,mBAClBK,SAAWL,QAAQ,oBACnBM,QAAUN,QAAQ,mBAClBO,iBAAmBP,QAAQ,uBAE3BQ,iBAAmB,SAASC,GAM5B,OAHYC,MAAMC,QAAQF,EAAKG,OAC3BH,EAAKG,MAAQF,MAAMD,IAK3BF,iBAAiBM,aACbC,MAAO,SAASC,GACZ,OAAOA,GAEXC,QAAS,SAASC,EAAQC,GAGtB,OAFAA,EAAQA,EAAMN,MAAQ,EAEfJ,iBAAiBS,GAAQC,IAEpCC,OAAQ,SAASF,GACb,OAAO,IAAIhB,UAAUO,iBAAiBS,GAAQE,SAUlDC,MAAO,SAASC,EAAOC,EAAKC,GACxB,IAAIC,EAAMC,EAAIC,EAAY,EAAGC,KACzBL,GACAG,EAAKH,EACLE,EAAOH,EAAMT,MACTW,IACAG,EAAYH,EAAKX,SAIrBY,EAAO,EACPC,EAAKJ,GAGT,IAAK,IAAIO,EAAIJ,EAAMI,GAAKH,EAAGb,MAAOgB,GAAKF,EACnCC,EAAKE,KAAK,IAAI5B,UAAU2B,EAAGH,EAAGK,OAGlC,OAAO,IAAI3B,WAAWwB,IAE1BI,KAAM,SAASJ,EAAMK,GACjB,IAAgBC,EAAUC,EAAtBC,KAIID,EAFJP,EAAKf,MACDF,MAAMC,QAAQgB,EAAKf,OACRe,EAAKf,OAEJe,EAAKf,OAEde,EAAKS,QACDT,EAAKS,QAAQD,MACjBR,EAAKQ,MACDR,EAAKQ,MACTzB,MAAMC,QAAQgB,GACVA,GAECA,GAGhB,IAAIU,EAAY,SACZC,EAAU,OACVC,EAAY,SAEZP,EAAGQ,QACHH,EAAYL,EAAGQ,OAAO,IAAMR,EAAGQ,OAAO,GAAGC,KACzCH,EAAUN,EAAGQ,OAAO,IAAMR,EAAGQ,OAAO,GAAGC,KACvCF,EAAYP,EAAGQ,OAAO,IAAMR,EAAGQ,OAAO,GAAGC,KACzCT,EAAKA,EAAGG,OAERH,EAAKA,EAAGI,QAGZ,IAAK,IAAIR,EAAI,EAAGA,EAAIM,EAASf,OAAQS,IAAK,CACtC,IAAIc,EAAK9B,EAAO+B,EAAOT,EAASN,GAC5Be,aAAgBzC,aAChBwC,EAA2B,iBAAdC,EAAKF,KAAoBE,EAAKF,KAAOE,EAAKF,KAAK,GAAG7B,MAC/DA,EAAQ+B,EAAK/B,QAEb8B,EAAM,IAAIzC,UAAU2B,EAAI,GACxBhB,EAAQ+B,GAGRA,aAAgB5C,UAIpBkC,EAAWD,EAAGG,MAAMS,MAAM,GACtBP,GACAJ,EAASJ,KAAK,IAAI3B,YAAYmC,EAC1BzB,GACA,GAAO,EAAOiC,KAAK3B,MAAO2B,KAAKC,kBAEnCP,GACAN,EAASJ,KAAK,IAAI3B,YAAYqC,EAC1B,IAAItC,UAAU2B,EAAI,IAClB,GAAO,EAAOiB,KAAK3B,MAAO2B,KAAKC,kBAEnCR,GACAL,EAASJ,KAAK,IAAI3B,YAAYoC,EAC1BI,GACA,GAAO,EAAOG,KAAK3B,MAAO2B,KAAKC,kBAGvCX,EAAMN,KAAK,IAAIzB,SAAU,IAAG,UAAa,IAAIE,QAAQ,GAAI,QACrD2B,EACAD,EAAGe,cACHf,EAAGgB,oBAIX,OAAO,IAAI5C,SAAU,IAAG,UAAa,IAAIE,QAAQ,GAAI,QAC7C6B,EACAH,EAAGe,cACHf,EAAGgB,kBACLC,KAAKJ,KAAKK","file":"../../../engine/functions/list.js","sourcesContent":["var Comment = require('../tree/comment'),\n    Dimension = require('../tree/dimension'),\n    Declaration = require('../tree/declaration'),\n    Expression = require('../tree/expression'),\n    Ruleset = require('../tree/ruleset'),\n    Selector = require('../tree/selector'),\n    Element = require('../tree/element'),\n    functionRegistry = require('./function-registry');\n\nvar getItemsFromNode = function(node) {\n    // handle non-array values as an array of length 1\n    // return 'undefined' if index is invalid\n    var items = Array.isArray(node.value) ?\n        node.value : Array(node);\n\n    return items;\n};\n\nfunctionRegistry.addMultiple({\n    _SELF: function(n) {\n        return n;\n    },\n    extract: function(values, index) {\n        index = index.value - 1; // (1-based index)\n\n        return getItemsFromNode(values)[index];\n    },\n    length: function(values) {\n        return new Dimension(getItemsFromNode(values).length);\n    },\n    /**\n     * Creates a Less list of incremental values.\n     * Modeled after Lodash's range function, also exists natively in PHP\n     * \n     * @param {Dimension} [start=1]\n     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output\n     * @param {Dimension} [step=1] \n     */\n    range: function(start, end, step) {\n        var from, to, stepValue = 1, list = [];\n        if (end) {\n            to = end;\n            from = start.value;\n            if (step) {\n                stepValue = step.value;\n            }\n        }\n        else {\n            from = 1;\n            to = start;\n        }\n\n        for (var i = from; i <= to.value; i += stepValue) {\n            list.push(new Dimension(i, to.unit));\n        }\n\n        return new Expression(list);\n    },\n    each: function(list, rs) {\n        var rules = [], newRules, iterator;\n\n        if (list.value) {\n            if (Array.isArray(list.value)) {\n                iterator = list.value;\n            } else {\n                iterator = [list.value];\n            }\n        } else if (list.ruleset) {\n            iterator = list.ruleset.rules;\n        } else if (list.rules) {\n            iterator = list.rules;\n        } else if (Array.isArray(list)) {\n            iterator = list;\n        } else {\n            iterator = [list];\n        }\n\n        var valueName = '@value',\n            keyName = '@key',\n            indexName = '@index';\n\n        if (rs.params) {\n            valueName = rs.params[0] && rs.params[0].name;\n            keyName = rs.params[1] && rs.params[1].name;\n            indexName = rs.params[2] && rs.params[2].name;\n            rs = rs.rules;\n        } else {\n            rs = rs.ruleset;\n        }\n\n        for (var i = 0; i < iterator.length; i++) {\n            var key, value, item = iterator[i];\n            if (item instanceof Declaration) {\n                key = typeof item.name === 'string' ? item.name : item.name[0].value;\n                value = item.value;\n            } else {\n                key = new Dimension(i + 1);\n                value = item;\n            }\n            \n            if (item instanceof Comment) {\n                continue;\n            }\n\n            newRules = rs.rules.slice(0);\n            if (valueName) {\n                newRules.push(new Declaration(valueName,\n                    value,\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (indexName) {\n                newRules.push(new Declaration(indexName,\n                    new Dimension(i + 1),\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (keyName) {\n                newRules.push(new Declaration(keyName,\n                    key,\n                    false, false, this.index, this.currentFileInfo));\n            }\n        \n            rules.push(new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                newRules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ));\n        }\n\n        return new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                rules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ).eval(this.context);\n\n    }\n});\n"]}