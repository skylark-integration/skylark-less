{"version":3,"sources":["engine/parser/parser-input.js"],"names":["chunker","require","module","exports","input","j","furthest","furthestPossibleErrorMessage","chunks","current","currentPos","saveStack","parserInput","CHARCODE_SPACE","CHARCODE_TAB","CHARCODE_LF","CHARCODE_CR","CHARCODE_FORWARD_SLASH","skipWhitespace","length","c","nextChar","comment","oldi","i","oldj","curr","endIndex","mem","inp","charCodeAt","autoCommentAbsorb","charAt","index","isLineComment","nextNewLine","indexOf","text","substr","commentStore","push","nextStarSlash","slice","finished","save","restore","possibleErrorMessage","state","pop","forget","isWhitespace","offset","pos","code","$re","tok","m","exec","$char","$str","tokLength","$quoted","loc","startChar","currentPosition","str","$parseUntil","testChar","quote","returnVal","inComment","blockDepth","blockStack","parseGroups","startPos","lastPos","loop","char","test","expected","peek","peekChar","currentChar","prevChar","getInput","peekNotNumeric","start","chunkInput","failFunction","end","message","isFinished","furthestReachedEnd","furthestChar"],"mappings":"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","file":"../../../engine/parser/parser-input.js","sourcesContent":["var chunker = require('./chunker');\nmodule.exports = function () {\n    var input, j, saveStack = [], furthest, furthestPossibleErrorMessage, chunks, current, currentPos, parserInput = {};\n    var CHARCODE_SPACE = 32, CHARCODE_TAB = 9, CHARCODE_LF = 10, CHARCODE_CR = 13, CHARCODE_PLUS = 43, CHARCODE_COMMA = 44, CHARCODE_FORWARD_SLASH = 47, CHARCODE_9 = 57;\n    function skipWhitespace(length) {\n        var oldi = parserInput.i, oldj = j, curr = parserInput.i - currentPos, endIndex = parserInput.i + current.length - curr, mem = parserInput.i += length, inp = input, c, nextChar, comment;\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {\n                        index: parserInput.i,\n                        isLineComment: true\n                    };\n                    var nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n            if (c !== CHARCODE_SPACE && c !== CHARCODE_LF && c !== CHARCODE_TAB && c !== CHARCODE_CR) {\n                break;\n            }\n        }\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0);\n                return true;\n            }\n            parserInput.finished = true;\n        }\n        return oldi !== parserInput.i || oldj !== j;\n    }\n    parserInput.save = function () {\n        currentPos = parserInput.i;\n        saveStack.push({\n            current: current,\n            i: parserInput.i,\n            j: j\n        });\n    };\n    parserInput.restore = function (possibleErrorMessage) {\n        if (parserInput.i > furthest || parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        var state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = function () {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = function (offset) {\n        var pos = parserInput.i + (offset || 0), code = input.charCodeAt(pos);\n        return code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF;\n    };\n    parserInput.$re = function (tok) {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n        var m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n        skipWhitespace(m[0].length);\n        if (typeof m === 'string') {\n            return m;\n        }\n        return m.length === 1 ? m[0] : m;\n    };\n    parserInput.$char = function (tok) {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n    parserInput.$str = function (tok) {\n        var tokLength = tok.length;\n        for (var i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n        skipWhitespace(tokLength);\n        return tok;\n    };\n    parserInput.$quoted = function (loc) {\n        var pos = loc || parserInput.i, startChar = input.charAt(pos);\n        if (startChar !== \"'\" && startChar !== '\"') {\n            return;\n        }\n        var length = input.length, currentPosition = pos;\n        for (var i = 1; i + currentPosition < length; i++) {\n            var nextChar = input.charAt(i + currentPosition);\n            switch (nextChar) {\n            case '\\\\':\n                i++;\n                continue;\n            case '\\r':\n            case '\\n':\n                break;\n            case startChar:\n                var str = input.substr(currentPosition, i + 1);\n                if (!loc && loc !== 0) {\n                    skipWhitespace(i + 1);\n                    return str;\n                }\n                return [\n                    startChar,\n                    str\n                ];\n            default:\n            }\n        }\n        return null;\n    };\n    parserInput.$parseUntil = function (tok) {\n        var quote = '', returnVal = null, inComment = false, blockDepth = 0, blockStack = [], parseGroups = [], length = input.length, startPos = parserInput.i, lastPos = parserInput.i, i = parserInput.i, loop = true, testChar;\n        if (typeof tok === 'string') {\n            testChar = function (char) {\n                return char === tok;\n            };\n        } else {\n            testChar = function (char) {\n                return tok.test(char);\n            };\n        }\n        do {\n            var prevChar, nextChar = input.charAt(i);\n            if (blockDepth === 0 && testChar(nextChar)) {\n                returnVal = input.substr(lastPos, i - lastPos);\n                if (returnVal) {\n                    parseGroups.push(returnVal);\n                } else {\n                    parseGroups.push(' ');\n                }\n                returnVal = parseGroups;\n                skipWhitespace(i - startPos);\n                loop = false;\n            } else {\n                if (inComment) {\n                    if (nextChar === '*' && input.charAt(i + 1) === '/') {\n                        i++;\n                        blockDepth--;\n                        inComment = false;\n                    }\n                    i++;\n                    continue;\n                }\n                switch (nextChar) {\n                case '\\\\':\n                    i++;\n                    nextChar = input.charAt(i);\n                    parseGroups.push(input.substr(lastPos, i - lastPos + 1));\n                    lastPos = i + 1;\n                    break;\n                case '/':\n                    if (input.charAt(i + 1) === '*') {\n                        i++;\n                        inComment = true;\n                        blockDepth++;\n                    }\n                    break;\n                case \"'\":\n                case '\"':\n                    quote = parserInput.$quoted(i);\n                    if (quote) {\n                        parseGroups.push(input.substr(lastPos, i - lastPos), quote);\n                        i += quote[1].length - 1;\n                        lastPos = i + 1;\n                    } else {\n                        skipWhitespace(i - startPos);\n                        returnVal = nextChar;\n                        loop = false;\n                    }\n                    break;\n                case '{':\n                    blockStack.push('}');\n                    blockDepth++;\n                    break;\n                case '(':\n                    blockStack.push(')');\n                    blockDepth++;\n                    break;\n                case '[':\n                    blockStack.push(']');\n                    blockDepth++;\n                    break;\n                case '}':\n                case ')':\n                case ']':\n                    var expected = blockStack.pop();\n                    if (nextChar === expected) {\n                        blockDepth--;\n                    } else {\n                        skipWhitespace(i - startPos);\n                        returnVal = expected;\n                        loop = false;\n                    }\n                }\n                i++;\n                if (i > length) {\n                    loop = false;\n                }\n            }\n            prevChar = nextChar;\n        } while (loop);\n        return returnVal ? returnVal : null;\n    };\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n    parserInput.peek = function (tok) {\n        if (typeof tok === 'string') {\n            for (var i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n    parserInput.peekChar = function (tok) {\n        return input.charAt(parserInput.i) === tok;\n    };\n    parserInput.currentChar = function () {\n        return input.charAt(parserInput.i);\n    };\n    parserInput.prevChar = function () {\n        return input.charAt(parserInput.i - 1);\n    };\n    parserInput.getInput = function () {\n        return input;\n    };\n    parserInput.peekNotNumeric = function () {\n        var c = input.charCodeAt(parserInput.i);\n        return c > CHARCODE_9 || c < CHARCODE_PLUS || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n    parserInput.start = function (str, chunkInput, failFunction) {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n        current = chunks[0];\n        skipWhitespace(0);\n    };\n    parserInput.end = function () {\n        var message, isFinished = parserInput.i >= input.length;\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished: isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n    return parserInput;\n};"]}