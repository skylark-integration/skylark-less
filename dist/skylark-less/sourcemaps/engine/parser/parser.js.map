{"version":3,"sources":["engine/parser/parser.js"],"names":["LessError","require","tree","visitors","getParserInput","utils","functionRegistry","Parser","context","imports","fileInfo","parsers","parserInput","error","msg","type","index","i","filename","message","expect","arg","result","Function","call","$re","currentChar","expectChar","$char","getDebugInfo","lineNumber","getLocation","getInput","line","fileName","parseNode","str","parseList","currentIndex","callback","returnNodes","parser","start","p","x","_index","_fileInfo","push","end","isFinished","e","parse","additionalData","root","globalVars","modifyVars","ignored","preText","serializeVars","pluginManager","preProcessors","getPreProcessors","length","process","banner","contentsIgnoredChars","replace","contents","chunkInput","Node","prototype","this","Ruleset","primary","rootNode","firstRoot","inherit","endInfo","furthestPossibleErrorMessage","furthestChar","furthestReachedEnd","furthest","finish","processImports","ImportVisitor","run","node","mixin","comment","finished","peek","extendRule","concat","definition","declaration","ruleset","variableCall","entities","atrule","foundSemiColon","commentStore","shift","Comment","text","isLineComment","mixinLookup","quoted","forceEscaped","isEscaped","save","restore","$quoted","forget","Quoted","charAt","substr","keyword","k","Color","fromKeyword","Keyword","name","args","func","customFuncCall","stop","arguments","Call","alpha","f","ieAlpha","boolean","condition","if","toLowerCase","prevArgs","isSemiColonSeparated","value","argsComma","argsSemiColon","detachedRuleset","assignment","expression","Value","literal","dimension","color","unicodeDescriptor","key","entity","Assignment","url","autoCommentAbsorb","$str","variable","property","URL","Variable","Property","Anonymous","ch","prevChar","match","variableCurly","curly","propertyCurly","rgb","undefined","colorKeyword","peekNotNumeric","Dimension","ud","UnicodeDescriptor","javascript","js","escape","JavaScript","Boolean","parsedName","lookups","important","inValue","ruleLookups","VariableCall","NamespaceValue","extend","isRule","elements","option","extendList","element","Extend","Selector","getLookup","hasParens","s","c","elem","elemIndex","re","Element","isCall","expressionContainsNamed","nameLoop","expand","returner","variadic","expressions","hasSep","throwAwayComments","val","cond","params","argInfo","conditions","block","Definition","rule","lookupValue","slice","v","combinator","attribute","selector","Paren","slashedCombinator","Combinator","isWhitespace","isLess","allExtends","when","selectors","op","Attribute","content","blockRuleset","DetachedRuleset","rules","debugInfo","dumpLineNumbers","strictImports","hasDR","merge","isVariable","ruleProperty","pop","permissiveValue","anonymousValue","Declaration","untilTokens","done","tok","testCurrentChar","char","test","Expression","$parseUntil","item","Array","isArray","trim","quote","variableRegex","propRegex","import","path","features","dir","options","importOptions","mediaFeatures","Import","o","optionName","importOption","opt","mediaFeature","nodes","media","Media","plugin","pluginArgs","isPlugin","nonVendorSpecificName","hasIdentifier","hasExpression","hasUnknown","hasBlock","isRooted","indexOf","AtRule","sub","a","addition","parens","multiplication","m","operation","isSpaced","operand","parensInOp","Operation","b","Condition","needsParens","logical","next","conditionAnd","self","negatedCondition","parenthesisCondition","atomicCondition","negate","body","me","tryConditionFollowedByParenthesis","bind","Negative","delim","simpleProperty","chunk","vars","Object","hasOwnProperty","String","module","exports"],"mappings":"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","file":"../../../engine/parser/parser.js","sourcesContent":["var LessError = require('../less-error'), tree = require('../tree'), visitors = require('../visitors'), getParserInput = require('./parser-input'), utils = require('../utils'), functionRegistry = require('../functions/function-registry');\nvar Parser = function Parser(context, imports, fileInfo) {\n    var parsers, parserInput = getParserInput();\n    function error(msg, type) {\n        throw new LessError({\n            index: parserInput.i,\n            filename: fileInfo.filename,\n            type: type || 'Syntax',\n            message: msg\n        }, imports);\n    }\n    function expect(arg, msg) {\n        var result = arg instanceof Function ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        error(msg || (typeof arg === 'string' ? \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\" : 'unexpected token'));\n    }\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || \"expected '\" + arg + \"' got '\" + parserInput.currentChar() + \"'\");\n    }\n    function getDebugInfo(index) {\n        var filename = fileInfo.filename;\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n    function parseNode(str, parseList, currentIndex, fileInfo, callback) {\n        var result, returnNodes = [];\n        var parser = parserInput;\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (var x = 0, p, i; p = parseList[x]; x++) {\n                i = parser.i;\n                result = parsers[p]();\n                if (result) {\n                    result._index = i + currentIndex;\n                    result._fileInfo = fileInfo;\n                    returnNodes.push(result);\n                } else {\n                    returnNodes.push(null);\n                }\n            }\n            var endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            } else {\n                callback(true, null);\n            }\n        } catch (e) {\n            throw new LessError({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }\n    return {\n        parserInput: parserInput,\n        imports: imports,\n        fileInfo: fileInfo,\n        parseNode: parseNode,\n        parse: function (str, callback, additionalData) {\n            var root, error = null, globalVars, modifyVars, ignored, preText = '';\n            globalVars = additionalData && additionalData.globalVars ? Parser.serializeVars(additionalData.globalVars) + '\\n' : '';\n            modifyVars = additionalData && additionalData.modifyVars ? '\\n' + Parser.serializeVars(additionalData.modifyVars) : '';\n            if (context.pluginManager) {\n                var preProcessors = context.pluginManager.getPreProcessors();\n                for (var i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, {\n                        context: context,\n                        imports: imports,\n                        fileInfo: fileInfo\n                    });\n                }\n            }\n            if (globalVars || additionalData && additionalData.banner) {\n                preText = (additionalData && additionalData.banner ? additionalData.banner : '') + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n            str = str.replace(/\\r\\n?/g, '\\n');\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index: index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n                tree.Node.prototype.parse = this;\n                root = new tree.Ruleset(null, this.parsers.primary());\n                tree.Node.prototype.rootNode = root;\n                root.root = true;\n                root.firstRoot = true;\n                root.functionRegistry = functionRegistry.inherit();\n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n            var endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n                var message = endInfo.furthestPossibleErrorMessage;\n                if (!message) {\n                    message = 'Unrecognised input';\n                    if (endInfo.furthestChar === '}') {\n                        message += \". Possibly missing opening '{'\";\n                    } else if (endInfo.furthestChar === ')') {\n                        message += \". Possibly missing opening '('\";\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += '. Possibly missing something';\n                    }\n                }\n                error = new LessError({\n                    type: 'Parse',\n                    message: message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n            var finish = function (e) {\n                e = error || e || imports.error;\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n                    return callback(e);\n                } else {\n                    return callback(null, root);\n                }\n            };\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish).run(root);\n            } else {\n                return finish();\n            }\n        },\n        parsers: parsers = {\n            primary: function () {\n                var mixin = this.mixin, root = [], node;\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) {\n                            break;\n                        }\n                        root.push(node);\n                    }\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n                    node = mixin.definition() || this.declaration() || this.ruleset() || mixin.call(false, false) || this.variableCall() || this.entities.call() || this.atrule();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        var foundSemiColon = false;\n                        while (parserInput.$char(';')) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n                return root;\n            },\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    var comment = parserInput.commentStore.shift();\n                    return new tree.Comment(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n            entities: {\n                mixinLookup: function () {\n                    return parsers.mixin.call(true, true);\n                },\n                quoted: function (forceEscaped) {\n                    var str, index = parserInput.i, isEscaped = false;\n                    parserInput.save();\n                    if (parserInput.$char('~')) {\n                        isEscaped = true;\n                    } else if (forceEscaped) {\n                        parserInput.restore();\n                        return;\n                    }\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n                    return new tree.Quoted(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n                keyword: function () {\n                    var k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new tree.Keyword(k);\n                    }\n                },\n                call: function () {\n                    var name, args, func, index = parserInput.i;\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n                    parserInput.save();\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) {\n                        parserInput.forget();\n                        return;\n                    }\n                    name = name[1];\n                    func = this.customFuncCall(name);\n                    if (func) {\n                        args = func.parse();\n                        if (args && func.stop) {\n                            parserInput.forget();\n                            return args;\n                        }\n                    }\n                    args = this.arguments(args);\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore(\"Could not parse call arguments or missing ')'\");\n                        return;\n                    }\n                    parserInput.forget();\n                    return new tree.Call(name, args, index, fileInfo);\n                },\n                customFuncCall: function (name) {\n                    return {\n                        alpha: f(parsers.ieAlpha, true),\n                        boolean: f(condition),\n                        'if': f(condition)\n                    }[name.toLowerCase()];\n                    function f(parse, stop) {\n                        return {\n                            parse: parse,\n                            stop: stop\n                        };\n                    }\n                    function condition() {\n                        return [expect(parsers.condition, 'expected condition')];\n                    }\n                },\n                arguments: function (prevArgs) {\n                    var argsComma = prevArgs || [], argsSemiColon = [], isSemiColonSeparated, value;\n                    parserInput.save();\n                    while (true) {\n                        if (prevArgs) {\n                            prevArgs = false;\n                        } else {\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n                            if (!value) {\n                                break;\n                            }\n                            if (value.value && value.value.length == 1) {\n                                value = value.value[0];\n                            }\n                            argsComma.push(value);\n                        }\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n                            isSemiColonSeparated = true;\n                            value = argsComma.length < 1 ? argsComma[0] : new tree.Value(argsComma);\n                            argsSemiColon.push(value);\n                            argsComma = [];\n                        }\n                    }\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() || this.color() || this.quoted() || this.unicodeDescriptor();\n                },\n                assignment: function () {\n                    var key, value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new tree.Assignment(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n                url: function () {\n                    var value, index = parserInput.i;\n                    parserInput.autoCommentAbsorb = false;\n                    if (!parserInput.$str('url(')) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n                    value = this.quoted() || this.variable() || this.property() || parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || '';\n                    parserInput.autoCommentAbsorb = true;\n                    expectChar(')');\n                    return new tree.URL(value.value != null || value instanceof tree.Variable || value instanceof tree.Property ? value : new tree.Anonymous(value, index), index, fileInfo);\n                },\n                variable: function () {\n                    var ch, name, index = parserInput.i;\n                    parserInput.save();\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        ch = parserInput.currentChar();\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\n                            var result = parsers.variableCall(name);\n                            if (result) {\n                                parserInput.forget();\n                                return result;\n                            }\n                        }\n                        parserInput.forget();\n                        return new tree.Variable(name, index, fileInfo);\n                    }\n                    parserInput.restore();\n                },\n                variableCurly: function () {\n                    var curly, index = parserInput.i;\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new tree.Variable('@' + curly[1], index, fileInfo);\n                    }\n                },\n                property: function () {\n                    var name, index = parserInput.i;\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\n                        return new tree.Property(name, index, fileInfo);\n                    }\n                },\n                propertyCurly: function () {\n                    var curly, index = parserInput.i;\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\n                        return new tree.Property('$' + curly[1], index, fileInfo);\n                    }\n                },\n                color: function () {\n                    var rgb;\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})/))) {\n                        return new tree.Color(rgb[1], undefined, rgb[0]);\n                    }\n                },\n                colorKeyword: function () {\n                    parserInput.save();\n                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    var color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n                    var value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new tree.Dimension(value[1], value[2]);\n                    }\n                },\n                unicodeDescriptor: function () {\n                    var ud;\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new tree.UnicodeDescriptor(ud[0]);\n                    }\n                },\n                javascript: function () {\n                    var js, index = parserInput.i;\n                    parserInput.save();\n                    var escape = parserInput.$char('~');\n                    var jsQuote = parserInput.$char('`');\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new tree.JavaScript(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }\n            },\n            variable: function () {\n                var name;\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) {\n                    return name[1];\n                }\n            },\n            variableCall: function (parsedName) {\n                var lookups, important, i = parserInput.i, inValue = !!parsedName, name = parsedName;\n                parserInput.save();\n                if (name || parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/))) {\n                    lookups = this.mixin.ruleLookups();\n                    if (!lookups && (inValue && parserInput.$str('()') !== '()' || name[2] !== '()')) {\n                        parserInput.restore(\"Missing '[...]' lookup in variable call\");\n                        return;\n                    }\n                    if (!inValue) {\n                        name = name[1];\n                    }\n                    if (lookups && parsers.important()) {\n                        important = true;\n                    }\n                    var call = new tree.VariableCall(name, i, fileInfo);\n                    if (!inValue && parsers.end()) {\n                        parserInput.forget();\n                        return call;\n                    } else {\n                        parserInput.forget();\n                        return new tree.NamespaceValue(call, lookups, important, i, fileInfo);\n                    }\n                }\n                parserInput.restore();\n            },\n            extend: function (isRule) {\n                var elements, e, index = parserInput.i, option, extendList, extend;\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n                    return;\n                }\n                do {\n                    option = null;\n                    elements = null;\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [e];\n                        }\n                    }\n                    option = option && option[1];\n                    if (!elements) {\n                        error('Missing target selector for :extend().');\n                    }\n                    extend = new tree.Extend(new tree.Selector(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [extend];\n                    }\n                } while (parserInput.$char(','));\n                expect(/^\\)/);\n                if (isRule) {\n                    expect(/^;/);\n                }\n                return extendList;\n            },\n            extendRule: function () {\n                return this.extend(true);\n            },\n            mixin: {\n                call: function (inValue, getLookup) {\n                    var s = parserInput.currentChar(), important = false, lookups, index = parserInput.i, elements, args, hasParens;\n                    if (s !== '.' && s !== '#') {\n                        return;\n                    }\n                    parserInput.save();\n                    elements = this.elements();\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                            hasParens = true;\n                        }\n                        if (getLookup !== false) {\n                            lookups = this.ruleLookups();\n                        }\n                        if (getLookup === true && !lookups) {\n                            parserInput.restore();\n                            return;\n                        }\n                        if (inValue && !lookups && !hasParens) {\n                            parserInput.restore();\n                            return;\n                        }\n                        if (!inValue && parsers.important()) {\n                            important = true;\n                        }\n                        if (inValue || parsers.end()) {\n                            parserInput.forget();\n                            var mixin = new tree.mixin.Call(elements, args, index, fileInfo, !lookups && important);\n                            if (lookups) {\n                                return new tree.NamespaceValue(mixin, lookups, important);\n                            } else {\n                                return mixin;\n                            }\n                        }\n                    }\n                    parserInput.restore();\n                },\n                elements: function () {\n                    var elements, e, c, elem, elemIndex, re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(re);\n                        if (!e) {\n                            break;\n                        }\n                        elem = new tree.Element(c, e, false, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [elem];\n                        }\n                        c = parserInput.$char('>');\n                    }\n                    return elements;\n                },\n                args: function (isCall) {\n                    var entities = parsers.entities, returner = {\n                            args: null,\n                            variadic: false\n                        }, expressions = [], argsSemiColon = [], argsComma = [], isSemiColonSeparated, expressionContainsNamed, name, nameLoop, value, arg, expand, hasSep = true;\n                    parserInput.save();\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str('...')) {\n                                returner.variadic = true;\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma).push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\n                        }\n                        if (!arg || !hasSep) {\n                            break;\n                        }\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        var val = null;\n                        if (isCall) {\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n                        if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error('Cannot mix ; and , as delimiter types');\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n                                value = parsers.detachedRuleset() || parsers.expression();\n                                if (!value) {\n                                    if (isCall) {\n                                        error('could not understand value for named argument');\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = name = val.name;\n                            } else if (parserInput.$str('...')) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma).push({\n                                        name: arg.name,\n                                        variadic: true\n                                    });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n                        if (value) {\n                            expressions.push(value);\n                        }\n                        argsComma.push({\n                            name: nameLoop,\n                            value: value,\n                            expand: expand\n                        });\n                        if (parserInput.$char(',')) {\n                            hasSep = true;\n                            continue;\n                        }\n                        hasSep = parserInput.$char(';') === ';';\n                        if (hasSep || isSemiColonSeparated) {\n                            if (expressionContainsNamed) {\n                                error('Cannot mix ; and , as delimiter types');\n                            }\n                            isSemiColonSeparated = true;\n                            if (expressions.length > 1) {\n                                value = new tree.Value(expressions);\n                            }\n                            argsSemiColon.push({\n                                name: name,\n                                value: value,\n                                expand: expand\n                            });\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                definition: function () {\n                    var name, params = [], match, ruleset, cond, variadic = false;\n                    if (parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#' || parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n                    parserInput.save();\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n                        var argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore(\"Missing closing ')'\");\n                            return;\n                        }\n                        parserInput.commentStore.length = 0;\n                        if (parserInput.$str('when')) {\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n                        ruleset = parsers.block();\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new tree.mixin.Definition(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                },\n                ruleLookups: function () {\n                    var rule, args, lookups = [];\n                    if (parserInput.currentChar() !== '[') {\n                        return;\n                    }\n                    while (true) {\n                        parserInput.save();\n                        args = null;\n                        rule = this.lookupValue();\n                        if (!rule && rule !== '') {\n                            parserInput.restore();\n                            break;\n                        }\n                        lookups.push(rule);\n                        parserInput.forget();\n                    }\n                    if (lookups.length > 0) {\n                        return lookups;\n                    }\n                },\n                lookupValue: function () {\n                    parserInput.save();\n                    if (!parserInput.$char('[')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\n                    if (!parserInput.$char(']')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (name || name === '') {\n                        parserInput.forget();\n                        return name;\n                    }\n                    parserInput.restore();\n                }\n            },\n            entity: function () {\n                var entities = this.entities;\n                return this.comment() || entities.literal() || entities.variable() || entities.url() || entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) || entities.javascript();\n            },\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n            ieAlpha: function () {\n                var value;\n                if (!parserInput.$re(/^opacity=/i)) {\n                    return;\n                }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\n                    value = '@{' + value.name.slice(1) + '}';\n                }\n                expectChar(')');\n                return new tree.Quoted('', 'alpha(opacity=' + value + ')');\n            },\n            element: function () {\n                var e, c, v, index = parserInput.i;\n                c = this.combinator();\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) || parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) || parserInput.$char('*') || parserInput.$char('&') || this.attribute() || parserInput.$re(/^\\([^&()@]+\\)/) || parserInput.$re(/^[\\.#:](?=@)/) || this.entities.variableCurly();\n                if (!e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\n                            e = new tree.Paren(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore(\"Missing closing ')'\");\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n                if (e) {\n                    return new tree.Element(c, e, e instanceof tree.Variable, index, fileInfo);\n                }\n            },\n            combinator: function () {\n                var c = parserInput.currentChar();\n                if (c === '/') {\n                    parserInput.save();\n                    var slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new tree.Combinator(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) {\n                        parserInput.i++;\n                    }\n                    return new tree.Combinator(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new tree.Combinator(' ');\n                } else {\n                    return new tree.Combinator(null);\n                }\n            },\n            selector: function (isLess) {\n                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;\n                isLess = isLess !== false;\n                while (isLess && (extendList = this.extend()) || isLess && (when = parserInput.$str('when')) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error('CSS guard can only be used at the end of selector');\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) {\n                            error('Extend can only be used at the end of selector');\n                        }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [e];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n                if (elements) {\n                    return new tree.Selector(elements, allExtends, condition, index, fileInfo);\n                }\n                if (allExtends) {\n                    error('Extend must be used to extend a selector, it cannot be used on its own');\n                }\n            },\n            selectors: function () {\n                var s, selectors;\n                while (true) {\n                    s = this.selector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [s];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error('Guards are only currently allowed on a single selector.');\n                    }\n                    if (!parserInput.$char(',')) {\n                        break;\n                    }\n                    if (s.condition) {\n                        error('Guards are only currently allowed on a single selector.');\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n                return selectors;\n            },\n            attribute: function () {\n                if (!parserInput.$char('[')) {\n                    return;\n                }\n                var entities = this.entities, key, val, op;\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n                expectChar(']');\n                return new tree.Attribute(key, op, val);\n            },\n            block: function () {\n                var content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n            blockRuleset: function () {\n                var block = this.block();\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n            detachedRuleset: function () {\n                var argInfo, params, variadic;\n                parserInput.save();\n                if (parserInput.$re(/^[.#]\\(/)) {\n                    argInfo = this.mixin.args(false);\n                    params = argInfo.args;\n                    variadic = argInfo.variadic;\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                }\n                var blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    parserInput.forget();\n                    if (params) {\n                        return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);\n                    }\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n                parserInput.restore();\n            },\n            ruleset: function () {\n                var selectors, rules, debugInfo;\n                parserInput.save();\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n                selectors = this.selectors();\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    var ruleset = new tree.Ruleset(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            declaration: function () {\n                var name, value, index = parserInput.i, hasDR, c = parserInput.currentChar(), important, merge, isVariable;\n                if (c === '.' || c === '#' || c === '&' || c === ':') {\n                    return;\n                }\n                parserInput.save();\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === 'string';\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                        if (value) {\n                            hasDR = true;\n                        }\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\n                            value = this.permissiveValue();\n                        } else {\n                            value = this.anonymousValue();\n                        }\n                        if (value) {\n                            parserInput.forget();\n                            return new tree.Declaration(name, value, false, merge, index, fileInfo);\n                        }\n                        if (!value) {\n                            value = this.value();\n                        }\n                        if (value) {\n                            important = this.important();\n                        } else if (isVariable) {\n                            value = this.permissiveValue();\n                        }\n                    }\n                    if (value && (this.end() || hasDR)) {\n                        parserInput.forget();\n                        return new tree.Declaration(name, value, important, merge, index, fileInfo);\n                    } else {\n                        parserInput.restore();\n                    }\n                } else {\n                    parserInput.restore();\n                }\n            },\n            anonymousValue: function () {\n                var index = parserInput.i;\n                var match = parserInput.$re(/^([^.#@\\$+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new tree.Anonymous(match[1], index);\n                }\n            },\n            permissiveValue: function (untilTokens) {\n                var i, e, done, value, tok = untilTokens || ';', index = parserInput.i, result = [];\n                function testCurrentChar() {\n                    var char = parserInput.currentChar();\n                    if (typeof tok === 'string') {\n                        return char === tok;\n                    } else {\n                        return tok.test(char);\n                    }\n                }\n                if (testCurrentChar()) {\n                    return;\n                }\n                value = [];\n                do {\n                    e = this.comment();\n                    if (e) {\n                        value.push(e);\n                        continue;\n                    }\n                    e = this.entity();\n                    if (e) {\n                        value.push(e);\n                    }\n                } while (e);\n                done = testCurrentChar();\n                if (value.length > 0) {\n                    value = new tree.Expression(value);\n                    if (done) {\n                        return value;\n                    } else {\n                        result.push(value);\n                    }\n                    if (parserInput.prevChar() === ' ') {\n                        result.push(new tree.Anonymous(' ', index));\n                    }\n                }\n                parserInput.save();\n                value = parserInput.$parseUntil(tok);\n                if (value) {\n                    if (typeof value === 'string') {\n                        error(\"Expected '\" + value + \"'\", 'Parse');\n                    }\n                    if (value.length === 1 && value[0] === ' ') {\n                        parserInput.forget();\n                        return new tree.Anonymous('', index);\n                    }\n                    var item;\n                    for (i = 0; i < value.length; i++) {\n                        item = value[i];\n                        if (Array.isArray(item)) {\n                            result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));\n                        } else {\n                            if (i === value.length - 1) {\n                                item = item.trim();\n                            }\n                            var quote = new tree.Quoted(\"'\", item, true, index, fileInfo);\n                            quote.variableRegex = /@([\\w-]+)/g;\n                            quote.propRegex = /\\$([\\w-]+)/g;\n                            result.push(quote);\n                        }\n                    }\n                    parserInput.forget();\n                    return new tree.Expression(result, true);\n                }\n                parserInput.restore();\n            },\n            'import': function () {\n                var path, features, index = parserInput.i;\n                var dir = parserInput.$re(/^@import?\\s+/);\n                if (dir) {\n                    var options = (dir ? this.importOptions() : null) || {};\n                    if (path = this.entities.quoted() || this.entities.url()) {\n                        features = this.mediaFeatures();\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon or unrecognised media features on import');\n                        }\n                        features = features && new tree.Value(features);\n                        return new tree.Import(path, features, options, index, fileInfo);\n                    } else {\n                        parserInput.i = index;\n                        error('malformed import statement');\n                    }\n                }\n            },\n            importOptions: function () {\n                var o, options = {}, optionName, value;\n                if (!parserInput.$char('(')) {\n                    return null;\n                }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch (optionName) {\n                        case 'css':\n                            optionName = 'less';\n                            value = false;\n                            break;\n                        case 'once':\n                            optionName = 'multiple';\n                            value = false;\n                            break;\n                        }\n                        options[optionName] = value;\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n            importOption: function () {\n                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n            mediaFeature: function () {\n                var entities = this.entities, nodes = [], e, p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable() || entities.mixinLookup();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new tree.Paren(new tree.Declaration(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new tree.Paren(e));\n                            } else {\n                                error('badly formed media feature definition');\n                            }\n                        } else {\n                            error(\"Missing closing ')'\", 'Parse');\n                        }\n                    }\n                } while (e);\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new tree.Expression(nodes);\n                }\n            },\n            mediaFeatures: function () {\n                var entities = this.entities, features = [], e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    } else {\n                        e = entities.variable() || entities.mixinLookup();\n                        if (e) {\n                            features.push(e);\n                            if (!parserInput.$char(',')) {\n                                break;\n                            }\n                        }\n                    }\n                } while (e);\n                return features.length > 0 ? features : null;\n            },\n            media: function () {\n                var features, rules, media, debugInfo, index = parserInput.i;\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n                parserInput.save();\n                if (parserInput.$str('@media')) {\n                    features = this.mediaFeatures();\n                    rules = this.block();\n                    if (!rules) {\n                        error('media definitions require block statements after any features');\n                    }\n                    parserInput.forget();\n                    media = new tree.Media(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n                    return media;\n                }\n                parserInput.restore();\n            },\n            plugin: function () {\n                var path, args, options, index = parserInput.i, dir = parserInput.$re(/^@plugin?\\s+/);\n                if (dir) {\n                    args = this.pluginArgs();\n                    if (args) {\n                        options = {\n                            pluginArgs: args,\n                            isPlugin: true\n                        };\n                    } else {\n                        options = { isPlugin: true };\n                    }\n                    if (path = this.entities.quoted() || this.entities.url()) {\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon on @plugin');\n                        }\n                        return new tree.Import(path, null, options, index, fileInfo);\n                    } else {\n                        parserInput.i = index;\n                        error('malformed @plugin statement');\n                    }\n                }\n            },\n            pluginArgs: function () {\n                parserInput.save();\n                if (!parserInput.$char('(')) {\n                    parserInput.restore();\n                    return null;\n                }\n                var args = parserInput.$re(/^\\s*([^\\);]+)\\)\\s*/);\n                if (args[1]) {\n                    parserInput.forget();\n                    return args[1].trim();\n                } else {\n                    parserInput.restore();\n                    return null;\n                }\n            },\n            atrule: function () {\n                var index = parserInput.i, name, value, rules, nonVendorSpecificName, hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;\n                if (parserInput.currentChar() !== '@') {\n                    return;\n                }\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n                parserInput.save();\n                name = parserInput.$re(/^@[a-z-]+/);\n                if (!name) {\n                    return;\n                }\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = '@' + name.slice(name.indexOf('-', 2) + 1);\n                }\n                switch (nonVendorSpecificName) {\n                case '@charset':\n                    hasIdentifier = true;\n                    hasBlock = false;\n                    break;\n                case '@namespace':\n                    hasExpression = true;\n                    hasBlock = false;\n                    break;\n                case '@keyframes':\n                case '@counter-style':\n                    hasIdentifier = true;\n                    break;\n                case '@document':\n                case '@supports':\n                    hasUnknown = true;\n                    isRooted = false;\n                    break;\n                default:\n                    hasUnknown = true;\n                    break;\n                }\n                parserInput.commentStore.length = 0;\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error('expected ' + name + ' identifier');\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error('expected ' + name + ' expression');\n                    }\n                } else if (hasUnknown) {\n                    value = this.permissiveValue(/^[{;]/);\n                    hasBlock = parserInput.currentChar() === '{';\n                    if (!value) {\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\n                            error(name + ' rule is missing block or ending semi-colon');\n                        }\n                    } else if (!value.value) {\n                        value = null;\n                    }\n                }\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n                if (rules || !hasBlock && value && parserInput.$char(';')) {\n                    parserInput.forget();\n                    return new tree.AtRule(name, value, rules, index, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);\n                }\n                parserInput.restore('at-rule options not recognised');\n            },\n            value: function () {\n                var e, expressions = [], index = parserInput.i;\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (!parserInput.$char(',')) {\n                            break;\n                        }\n                    }\n                } while (e);\n                if (expressions.length > 0) {\n                    return new tree.Value(expressions, index);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                var a, e;\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new tree.Expression([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore(\"Expected ')'\");\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n                        parserInput.save();\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\n                        if (!op) {\n                            parserInput.forget();\n                            break;\n                        }\n                        a = this.operand();\n                        if (!a) {\n                            parserInput.restore();\n                            break;\n                        }\n                        parserInput.forget();\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new tree.Operation(op, [\n                            operation || m,\n                            a\n                        ], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                var m, a, op, operation, isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || !isSpaced && (parserInput.$char('+') || parserInput.$char('-'));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new tree.Operation(op, [\n                            operation || m,\n                            a\n                        ], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                var a, b, index = parserInput.i, condition;\n                a = this.condition(true);\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition(true);\n                        if (!b) {\n                            break;\n                        }\n                        condition = new tree.Condition('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function (needsParens) {\n                var result, logical, next;\n                function or() {\n                    return parserInput.$str('or');\n                }\n                result = this.conditionAnd(needsParens);\n                if (!result) {\n                    return;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition(needsParens);\n                    if (next) {\n                        result = new tree.Condition(logical, result, next);\n                    } else {\n                        return;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function (needsParens) {\n                var result, logical, next, self = this;\n                function insideCondition() {\n                    var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\n                    if (!cond && !needsParens) {\n                        return self.atomicCondition(needsParens);\n                    }\n                    return cond;\n                }\n                function and() {\n                    return parserInput.$str('and');\n                }\n                result = insideCondition();\n                if (!result) {\n                    return;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd(needsParens);\n                    if (next) {\n                        result = new tree.Condition(logical, result, next);\n                    } else {\n                        return;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function (needsParens) {\n                if (parserInput.$str('not')) {\n                    var result = this.parenthesisCondition(needsParens);\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function (needsParens) {\n                function tryConditionFollowedByParenthesis(me) {\n                    var body;\n                    parserInput.save();\n                    body = me.condition(needsParens);\n                    if (!body) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n                var body;\n                parserInput.save();\n                if (!parserInput.$str('(')) {\n                    parserInput.restore();\n                    return;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n                body = this.atomicCondition(needsParens);\n                if (!body) {\n                    parserInput.restore();\n                    return;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(\"expected ')' got '\" + parserInput.currentChar() + \"'\");\n                    return;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function (needsParens) {\n                var entities = this.entities, index = parserInput.i, a, b, c, op;\n                function cond() {\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\n                }\n                cond = cond.bind(this);\n                a = cond();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = '>=';\n                        } else {\n                            op = '>';\n                        }\n                    } else if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = '<=';\n                        } else {\n                            op = '<';\n                        }\n                    } else if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = '=>';\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = cond();\n                        if (b) {\n                            c = new tree.Condition(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new tree.Condition('=', a, new tree.Keyword('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n            operand: function () {\n                var entities = this.entities, negate;\n                if (parserInput.peek(/^-[@\\$\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n                var o = this.sub() || entities.dimension() || entities.color() || entities.variable() || entities.property() || entities.call() || entities.quoted(true) || entities.colorKeyword() || entities.mixinLookup();\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new tree.Negative(o);\n                }\n                return o;\n            },\n            expression: function () {\n                var entities = [], e, delim, index = parserInput.i;\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new tree.Anonymous(delim, index));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new tree.Expression(entities);\n                }\n            },\n            property: function () {\n                var name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                var name = [], index = [], s, k;\n                parserInput.save();\n                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new tree.Keyword(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n                function match(re) {\n                    var i = parserInput.i, chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:[@\\$]\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n                if (name.length > 1 && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = s.charAt(0) !== '@' && s.charAt(0) !== '$' ? new tree.Keyword(s) : s.charAt(0) === '@' ? new tree.Variable('@' + s.slice(2, -1), index[k], fileInfo) : new tree.Property('$' + s.slice(2, -1), index[k], fileInfo);\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = function (vars) {\n    var s = '';\n    for (var name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            var value = vars[name];\n            s += (name[0] === '@' ? '' : '@') + name + ': ' + value + (String(value).slice(-1) === ';' ? '' : ';');\n        }\n    }\n    return s;\n};\nmodule.exports = Parser;"]}