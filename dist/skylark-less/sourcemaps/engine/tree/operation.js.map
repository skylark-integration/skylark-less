{"version":3,"sources":["engine/tree/operation.js"],"names":["Node","require","Color","Dimension","MATH","Math","Operation","op","operands","isSpaced","this","trim","prototype","type","accept","visitor","visit","eval","context","a","b","isMathOn","toColor","operate","math","PARENS_DIVISION","message","genCSS","output","add","module","exports"],"mappings":";;;;;;;AAAA,IAAIA,KAAOC,QAAQ,UAAWC,MAAQD,QAAQ,WAAYE,UAAYF,QAAQ,eAAgBG,KAAOH,QAAQ,gBAAgBI,KACzHC,UAAY,SAAUC,EAAIC,EAAUC,GACpCC,KAAKH,GAAKA,EAAGI,OACbD,KAAKF,SAAWA,EAChBE,KAAKD,SAAWA,GAEpBH,UAAUM,UAAY,IAAIZ,KAC1BM,UAAUM,UAAUC,KAAO,YAC3BP,UAAUM,UAAUE,OAAS,SAAUC,GACnCL,KAAKF,SAAWO,EAAQC,MAAMN,KAAKF,WAEvCF,UAAUM,UAAUK,KAAO,SAAUC,GACjC,IAA4EX,EAAxEY,EAAIT,KAAKF,SAAS,GAAGS,KAAKC,GAAUE,EAAIV,KAAKF,SAAS,GAAGS,KAAKC,GAClE,GAAIA,EAAQG,SAASX,KAAKH,IAAK,CAQ3B,GAPAA,EAAiB,OAAZG,KAAKH,GAAc,IAAMG,KAAKH,GAC/BY,aAAahB,WAAaiB,aAAalB,QACvCiB,EAAIA,EAAEG,WAENF,aAAajB,WAAagB,aAAajB,QACvCkB,EAAIA,EAAEE,YAELH,EAAEI,QAAS,CACZ,GAAIJ,aAAab,WAAsB,MAATa,EAAEZ,IAAcW,EAAQM,OAASpB,KAAKqB,gBAChE,OAAO,IAAInB,UAAUI,KAAKH,IACtBY,EACAC,GACDV,KAAKD,UAEZ,MACII,KAAM,YACNa,QAAS,gCAGjB,OAAOP,EAAEI,QAAQL,EAASX,EAAIa,GAE9B,OAAO,IAAId,UAAUI,KAAKH,IACtBY,EACAC,GACDV,KAAKD,WAGhBH,UAAUM,UAAUe,OAAS,SAAUT,EAASU,GAC5ClB,KAAKF,SAAS,GAAGmB,OAAOT,EAASU,GAC7BlB,KAAKD,UACLmB,EAAOC,IAAI,KAEfD,EAAOC,IAAInB,KAAKH,IACZG,KAAKD,UACLmB,EAAOC,IAAI,KAEfnB,KAAKF,SAAS,GAAGmB,OAAOT,EAASU,IAErCE,OAAOC,QAAUzB","file":"../../../engine/tree/operation.js","sourcesContent":["var Node = require('./node'), Color = require('./color'), Dimension = require('./dimension'), MATH = require('../constants').Math;\nvar Operation = function (op, operands, isSpaced) {\n    this.op = op.trim();\n    this.operands = operands;\n    this.isSpaced = isSpaced;\n};\nOperation.prototype = new Node();\nOperation.prototype.type = 'Operation';\nOperation.prototype.accept = function (visitor) {\n    this.operands = visitor.visit(this.operands);\n};\nOperation.prototype.eval = function (context) {\n    var a = this.operands[0].eval(context), b = this.operands[1].eval(context), op;\n    if (context.isMathOn(this.op)) {\n        op = this.op === './' ? '/' : this.op;\n        if (a instanceof Dimension && b instanceof Color) {\n            a = a.toColor();\n        }\n        if (b instanceof Dimension && a instanceof Color) {\n            b = b.toColor();\n        }\n        if (!a.operate) {\n            if (a instanceof Operation && a.op === '/' && context.math === MATH.PARENS_DIVISION) {\n                return new Operation(this.op, [\n                    a,\n                    b\n                ], this.isSpaced);\n            }\n            throw {\n                type: 'Operation',\n                message: 'Operation on an invalid type'\n            };\n        }\n        return a.operate(context, op, b);\n    } else {\n        return new Operation(this.op, [\n            a,\n            b\n        ], this.isSpaced);\n    }\n};\nOperation.prototype.genCSS = function (context, output) {\n    this.operands[0].genCSS(context, output);\n    if (this.isSpaced) {\n        output.add(' ');\n    }\n    output.add(this.op);\n    if (this.isSpaced) {\n        output.add(' ');\n    }\n    this.operands[1].genCSS(context, output);\n};\nmodule.exports = Operation;"]}